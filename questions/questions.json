[
  {
    "id": "CN05000001",
    "subject_code": "CN",
    "chapter_num": "05",
    "question_type": "single_choice",
    "status": "published",
    "question_text": "下列关于IP数据报分片的说法中，错误的是（）。",
    "option_a": "相同长度的两个IP数据报从同一主机发送到其他网络的另一主机，若他们的路由路径不同，则到达时的分片情况可能不同",
    "option_b": "IPv6只允许在源节点分片，并在目的节点重组，不允许在中间节点分片和重组",
    "option_c": "在TCP传输时可以根据数据链路层的MTU确定MSS，从而避免在本地网络分片",
    "option_d": "IP数据报分片后，所有分片数据报的标志（Flags）位均相同，其中“禁止分片（DF）”位一定为0",
    "correct_answer": "D",
    "explanation": "Flags字段并不完全相同：除了最后一个分片，其他分片的MF位为1，而最后一个分片的MF位为0。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-10-19",
    "last_modified": "2025-10-19",
    "image_path": null
  },
  {
    "id": "CN05000002",
    "subject_code": "CN",
    "chapter_num": "05",
    "question_type": "single_choice",
    "status": "published",
    "question_text": "应用层程序使用TCP进行通信，则接收方程序一次读取的数据量为（）。",
    "option_a": "一个报文段中包含的数据",
    "option_b": "一个IP数据报中包含的数据",
    "option_c": "所有已经确认而还未被读取的数据",
    "option_d": "由程序的需求决定",
    "correct_answer": "D",
    "explanation": "TCP给应用程序提供的接口是字节流服务，应用程序感知不到报文段界限的存在。注意与UDP区分。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-10-19",
    "last_modified": "2025-10-19",
    "image_path": null
  },
  {
    "id": "CN05000003",
    "subject_code": "CN",
    "chapter_num": "05",
    "question_type": "single_choice",
    "status": "published",
    "question_text": "关于选择重传（Selective-Repeat）协议与TCP在确认机制上的区别，以下说法正确的是（）。",
    "option_a": "SR协议只能发送累积确认，而TCP默认支持对每个乱序到达的数据段单独确认",
    "option_b": "SR协议可以对每个正确接收的数据帧单独发送ACK，而TCP在默认情况下仅使用累积确认，不支持选择性确认",
    "option_c": "SR协议和TCP在默认情况下都支持选择性确认，因此两者在确认机制上没有本质区别",
    "option_d": "SR协议要求接收方丢弃所有乱序到达的帧，而TCP会缓存乱序段并等待缺失段到达后再按序交付",
    "correct_answer": "B",
    "explanation": "在SR协议中，接收方为每个正确接收的帧（即使乱序）单独发送ACK，并缓存这些帧，待缺失帧到达后按序交付给上层。\nTCP默认使用累积确认（cumulative ACK），即ACK号表示“期望收到的下一个字节”，隐含确认了之前所有数据。虽然TCP可通过 SACK（Selective Acknowledgment）选项 实现类似SR的选择性确认，但 SACK不是默认启用的，属于可选扩展。\n因此，在默认行为下，SR支持选择性确认，而TCP不支持，选项B正确。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-10-19",
    "last_modified": "2025-10-19",
    "image_path": null
  },
  {
    "id": "DS04000001",
    "subject_code": "DS",
    "chapter_num": "04",
    "question_type": "single_choice",
    "status": "published",
    "question_text": "一棵二叉树有500个叶节点，则该树中至少包含（）个节点。",
    "option_a": "501",
    "option_b": "998",
    "option_c": "999",
    "option_d": "1000",
    "correct_answer": "C",
    "explanation": "在任意二叉树中，叶节点数n_0与度为2的节点数n_2满足n_0=n_2+1。  \n当树中没有度为1的节点（即n_1=0，如最下层有偶数个节点的完全二叉树）时，总节点数最少。  \n此时总节点数为n=n_0+n_2=500+499=999。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-10-19",
    "last_modified": "2025-11-07",
    "image_path": null
  },
  {
    "id": "CN05000004",
    "subject_code": "CN",
    "chapter_num": "05",
    "question_type": "single_choice",
    "status": "published",
    "question_text": "在TCP连接中，发送方依次发送了以下三个报文段（每个100字节）：\n报文段 A：序列号 1000\n报文段 B：序列号 1100\n报文段 C：序列号 1200\n接收方先收到了B和C，但未收到A。一段时间后，有两种可能情况：\n情况I：在接收方缓存未超时前，A到达；\n情况II：A始终未到达，接收方因缓存超时丢弃了B和C。\n在这两种情况下，接收方最终发送的确认序列号分别是（）。",
    "option_a": "1300 1000",
    "option_b": "1300 1300",
    "option_c": "1000 1000",
    "option_d": "1100 1000",
    "correct_answer": "A",
    "explanation": "TCP 使用累计确认，ACK号表示“期望接收的下一个字节”。\n情况I：B和C被缓存，当A（1000–1099）到达后，接收方能按序交付1000–1299，因此发送ACK=1300。\n情况II：若缓存超时，B和C被丢弃，接收方从未“确认”它们。即使曾经收到，只要缺口（1000）未填补且缓存被清空，接收方仍只能ACK=1000，表示“仍在等待 1000”。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-10-19",
    "last_modified": "2025-10-19",
    "image_path": null
  },
  {
    "id": "CN05000005",
    "subject_code": "CN",
    "chapter_num": "05",
    "question_type": "single_choice",
    "status": "published",
    "question_text": "关于TCP中的标志位（Flags），以下说法正确的是（）。",
    "option_a": "在整个TCP通信过程中，除了第一次握手报文外，后续所有报文都必须设置ACK标志位。",
    "option_b": "无论是使用FIN还是RST标志来终止连接，都需要通过类似握手的交互过程来完成。",
    "option_c": "当一端收到带有RST标志的TCP报文后，必须重新建立连接。",
    "option_d": "URG标志用于指示该TCP报文段应被优先处理，其紧急数据的偏移由窗口大小字段指定。",
    "correct_answer": "A",
    "explanation": "A正确：从第二次握手（SYN+ACK）开始，所有TCP报文（包括三次握手的第三次、数据传输、四次挥手等）都必须置ACK=1。唯一不带ACK的是第一个SYN报文（即主动发起方发送的初始SYN）。因此，A选项的说法是准确的。\nB错误：FIN关闭需四次挥手，RST是立即终止，无需任何交互。\nC错误：收到RST表示连接被对端强制关闭，是否重建连接由应用程序决定。\nD错误：URG报文的紧急数据位置由紧急指针（Urgent-Pointer）字段指定，与窗口大小无关。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-10-19",
    "last_modified": "2025-10-19",
    "image_path": null
  },
  {
    "id": "CN05000006",
    "subject_code": "CN",
    "chapter_num": "05",
    "question_type": "single_choice",
    "status": "published",
    "question_text": "在一条已建立的TCP连接中，某时刻，主机A和B之前的所有数据均已正确传输并确认。\n此时，A向B发送一个携带300字节数据的报文段（Seq=1000）；几乎同时，B向A发送一个携带400字节数据的报文段（Seq=2000）。\n由于网络延迟，A发出的报文尚未到达B时，B已经发出了自己的报文，反之亦然。\n则B发送给A的报文段中的确认号（ACK）和A发送给B的报文段中的确认号（ACK）分别是（）。",
    "option_a": "1000 2000",
    "option_b": "1300 2400",
    "option_c": "1301 2401",
    "option_d": "两报文段的确认号均无效",
    "correct_answer": "A",
    "explanation": "由于A和B在发送报文时都尚未收到对方刚发出的数据（因网络延迟），各自的确认号仍基于之前已确认的状态。此前所有数据均已确认，因此：\nB未收到A的Seq=1000报文，ACK仍为1000；\nA未收到B的Seq=2000报文，ACK仍为2000。\n故两个报文段中的确认号分别为1000和2000。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-10-20",
    "last_modified": "2025-10-20",
    "image_path": null
  },
  {
    "id": "CN05000007",
    "subject_code": "CN",
    "chapter_num": "05",
    "question_type": "single_choice",
    "status": "published",
    "question_text": "以下关于IPv4与IPv6的说法中，错误的是（）。",
    "option_a": "IPv6将IPv4中的ARP和IGMP功能整合到ICMPv6中，通过邻居发现协议实现地址解析和组播管理。",
    "option_b": "IPv6禁止中间路由器分片，当数据包超过路径MTU时，路由器会向源主机返回ICMPv6“数据报过大”消息。",
    "option_c": "任播（Anycast）是IPv6新增的通信方式，IPv4无法实现任播功能。",
    "option_d": "IPv6在协议设计中内建了多种隧道机制，用于支持移动IPv6等场景。",
    "correct_answer": "C",
    "explanation": "任播并非IPv6独有，IPv4可通过将同一地址配置于多个节点实现任播（如DNS根服务器），只是未在协议中明确定义。因此“IPv4无法实现任播”说法错误。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-10-21",
    "last_modified": "2025-10-21",
    "image_path": null
  },
  {
    "id": "CO02000001",
    "subject_code": "CO",
    "chapter_num": "02",
    "question_type": "single_choice",
    "status": "published",
    "question_text": "关于整数乘除法的实现与优化，以下说法中正确的是：\nⅠ.无符号加法器、乘法器可以直接用于计算有符号补码的加法和乘法，无需任何修改。\nⅡ.若指令集架构不支持硬件乘法或除法指令，则可以通过软件算法（如移位、加减和循环）来实现乘除法功能。\nⅢ.阵列乘法器相比基于累加的多周期乘法器，在实现相同位宽的乘法时通常占用更大的芯片面积。\nⅣ.高级语言中的乘法或除法运算，在满足特定条件（如乘数/除数为2的幂）时，编译器可能会将其优化为移位运算指令。",
    "option_a": "仅Ⅱ、Ⅲ、Ⅳ",
    "option_b": "仅Ⅱ、Ⅳ",
    "option_c": "仅Ⅰ、Ⅱ、Ⅳ",
    "option_d": "仅Ⅲ、Ⅳ",
    "correct_answer": "A",
    "explanation": "Ⅰ错误：无符号加法器可用于有符号补码加法（因为补码加法与无符号加法在硬件上行为一致），但乘法器不能直接通用。有符号乘法需处理符号位扩展或使用Booth算法等，直接用无符号乘法器会得到错误结果。\nⅡ正确：早期RISC架构（如MIPS）没有硬件乘除指令，乘除通过软件库实现。\nⅢ正确：阵列乘法器是并行结构，延迟低但面积大；多周期乘法器复用加法器资源，面积小但需多个周期。\nⅣ正确：如乘2可以被优化为左移1位。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-10-26",
    "last_modified": "2025-10-26",
    "image_path": null
  },
  {
    "id": "OS02000001",
    "subject_code": "OS",
    "chapter_num": "02",
    "question_type": "single_choice",
    "status": "published",
    "question_text": "在基于页式虚拟内存管理的操作系统中，关于进程切换，以下说法正确的是（）。\nⅠ.进程切换时需要切换内核栈。\nⅡ.进程切换后，能够继续使用上一个进程的TLB表项加速内核和用户空间的地址翻译。\nⅢ.若不同进程共享内核地址空间，则进程切换时不需要切换任何页表。\nⅣ.当新进程的上下文已被设置好后，CPU通过执行中断返回类指令（如iret），从内核态返回到新进程的用户态，并开始执行其用户空间代码。",
    "option_a": "仅Ⅰ",
    "option_b": "仅Ⅰ、Ⅳ",
    "option_c": "仅Ⅰ、Ⅲ、Ⅳ",
    "option_d": "仅Ⅱ、Ⅲ、Ⅳ",
    "correct_answer": "B",
    "explanation": "Ⅰ正确：每个进程有自己独立的内核栈，用于保存内核态执行时的上下文（如系统调用、中断处理时的栈帧）。进程切换时必须切换内核栈。\nⅡ错误：TLB缓存的是虚拟地址到物理地址的映射，这些映射与当前页表（即当前进程）相关。若不刷新TLB，新进程可能误用旧进程的地址映射，导致错误。因此，进程切换通常需要刷新TLB（或使用ASID等机制隔离），不能直接复用上一个进程的TLB表项。\nⅢ错误：即使内核地址空间共享，用户地址空间不同，页表的用户部分必须切换。整个页表基址仍需更新，因此仍需切换页表。\nⅣ正确：进程切换后，新进程的上下文（包括用户态寄存器、程序计数器等）在内核中被构造好后，通过iret等中断返回指令完成特权级切换并跳转至用户态入口，从而开始执行用户代码。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-11-01",
    "last_modified": "2025-11-07",
    "image_path": null
  },
  {
    "id": "DS04000002",
    "subject_code": "DS",
    "chapter_num": "04",
    "question_type": "single_choice",
    "status": "published",
    "question_text": "如果需要设计一个数据结构，用于高效地实时维护一组动态数据的中位数，且要求插入和查询中位数操作的时间复杂度都尽可能低，哪个数据结构（组合）最合适？",
    "option_a": "一个大根堆和一个小根堆",
    "option_b": "双端队列",
    "option_c": "散列表",
    "option_d": "红黑树",
    "correct_answer": "A",
    "explanation": "大根堆和小根堆的组合是维护动态中位数的最优方案：大根堆存储较小的一半数字，小根堆存储较大的一半数字，通过保持两堆大小平衡，插入时只需将新数与堆顶比较后放入合适堆并可能调整堆间元素，时间复杂度为O(logn)，查询中位数则直接取堆顶元素，时间复杂度为O(1)。相比之下，双端队列无法快速维护有序性，散列表无序无法直接获取中位数，红黑树虽能给出全序，但是仍不能在常数时间找到中位数。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-11-07",
    "last_modified": "2025-11-07",
    "image_path": null
  },
  {
    "id": "CO03000001",
    "subject_code": "CO",
    "chapter_num": "03",
    "question_type": "single_choice",
    "status": "published",
    "question_text": "在闪存（Flash）中，以下三种基本操作的典型耗时从短到长的正确排序是（）。",
    "option_a": "擦除<编程<读取",
    "option_b": "读取<擦除<编程",
    "option_c": "读取<编程<擦除",
    "option_d": "编程<读取<擦除",
    "correct_answer": "C",
    "explanation": "在闪存中，三种基本操作的典型耗时排序基于其工作原理：读取操作仅需检测电荷状态，耗时最短；编程操作需改变电荷状态（如注入电子），耗时中等；擦除操作需以块为单位重置电荷（如移除电子），耗时最长。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-11-08",
    "last_modified": "2025-11-08",
    "image_path": null
  },
  {
    "id": "CO03000002",
    "subject_code": "CO",
    "chapter_num": "03",
    "question_type": "application",
    "status": "published",
    "question_text": "以下关于SRAM、DRAM和Flash存储器的说法中，哪些是正确的？\nⅠ.它们都可以进行随机访问，因此都属于随机访问存储器。\nⅡ.它们都基于电子器件实现，不含机械运动部件。\nⅢ.DRAM需要定时刷新以维持数据；而Flash存储器若要写入一个已有数据的页，必须先擦除该页所在的整个块。\nⅣ.在一台同时配备SRAM、DRAM和Flash存储器的计算机系统中，某个进程的数据可能同时分布在这三种存储器中。",
    "option_a": "",
    "option_b": "",
    "option_c": "",
    "option_d": "",
    "correct_answer": "C",
    "explanation": "Ⅰ错误：Flash属于只读存储器。\nⅡ正确：三者均为半导体存储器，没有机械部件（区别于HDD等）。\nⅢ正确。\nⅣ正确：例如，进程的数据缓存（SRAM）、主存（DRAM）、以及被换出的数据可能存于外存（Flash），因此数据可分布于三者中。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-11-11",
    "last_modified": "2025-11-11",
    "image_path": null
  },
  {
    "id": "DS07000001",
    "subject_code": "DS",
    "chapter_num": "07",
    "question_type": "single_choice",
    "status": "published",
    "question_text": "使用基数排序（最高位优先）对若干至多3位的十进制正整数升序排序。以下哪个序列不可能是第二趟收集之后的结果？",
    "option_a": "7, 15, 105, 150, 203, 888",
    "option_b": "45, 54, 111, 110, 234, 345",
    "option_c": "9, 8, 5, 22, 31, 121",
    "option_d": "100, 200, 101, 201, 4, 10",
    "correct_answer": "D",
    "explanation": "对于不足3位的数据，应视为高位为0。注意是最高位优先，所以可能的序列应该满足：只看百位和十位，组成的序列是升序的。A、B、C均符合，D不符合。",
    "knowledge": "",
    "notes": "",
    "created_date": "2025-11-21",
    "last_modified": "2025-11-21",
    "image_path": null
  }
]